import * as bip39 from 'bip39';
import { seedToId } from '@transmute/universal-wallet';
import { Jwk } from '@sidetree/core';
import { Multihash } from '@sidetree/common';
import * as ed25519 from '@transmute/did-key-ed25519';
import * as secp256k1 from '@transmute/did-key-secp256k1';
import base64url from 'base64url';

const generateMnemonic = async () => {
  const mnemonic = await bip39.generateMnemonic();
  return mnemonic;
};

const toMnemonic = async (mnemonic: string) => {
  const seed = await bip39.mnemonicToSeed(mnemonic);
  const id = await seedToId(seed);
  return {
    '@context': [
      'https://transmute-industries.github.io/universal-wallet/contexts/wallet-v1.json',
    ],
    id,
    name: 'Sidetree Mnemonic',
    image: 'https://via.placeholder.com/150',
    description: 'Generated by @sidetree/wallet.',
    tags: [],
    correlation: [],
    type: 'Mnemonic',
    value: mnemonic,
  };
};

const toKeyPair = async (keypair: any) => {
  return {
    '@context': [
      'https://transmute-industries.github.io/universal-wallet/contexts/wallet-v1.json',
    ],
    ...keypair,
    name: 'Sidetree KeyPair',
    image: 'https://via.placeholder.com/150',
    description: 'Generated by @sidetree/wallet.',
    tags: [],
    correlation: [],
  };
};

const toUniversalWalletDataModel = async (type: string, data: any) => {
  switch (type) {
    case 'Mnemonic': {
      return toMnemonic(data);
    }
    case 'KeyPair': {
      return toKeyPair(data);
    }
    default: {
      throw new Error('Unknown Universal Wallet Data Model Type; ' + type);
    }
  }
};

const getEd25519KeyPairFromMnemonicAtIndex = async (
  mnemonicContent: any,
  index: number
): Promise<any> => {
  const [
    publicKeyJwk,
    privateKeyJwk,
  ] = await Jwk.generateDeterministicEd25519KeyPair(
    mnemonicContent.value,
    index
  );
  const fingerprint = await ed25519.Ed25519KeyPair.fingerprintFromPublicKey({
    publicKeyBase58: await ed25519.keyUtils.publicKeyBase58FromPublicKeyJwk(
      publicKeyJwk
    ),
  });
  const ed25519KeyPair = await ed25519.Ed25519KeyPair.from({
    id: '#' + fingerprint,
    controller: '',
    publicKeyJwk,
    privateKeyJwk,
  });
  return ed25519KeyPair;
};

const getSecp256k1KeyPairFromMnemonicAtIndex = async (
  mnemonicContent: any,
  index: number
): Promise<any> => {
  const [
    publicKeyJwk,
    privateKeyJwk,
  ] = await Jwk.generateDeterministicSecp256k1KeyPair(
    mnemonicContent.value,
    index
  );
  const fingerprint = await secp256k1.Secp256k1KeyPair.fingerprintFromPublicKey(
    {
      publicKeyBase58: await secp256k1.keyUtils.publicKeyBase58FromPublicKeyHex(
        await secp256k1.keyUtils.publicKeyHexFromJwk(publicKeyJwk as any)
      ),
    }
  );
  const secp256k1KeyPair = await secp256k1.Secp256k1KeyPair.from({
    id: '#' + fingerprint,
    controller: '',
    publicKeyJwk,
    privateKeyJwk,
  });
  return secp256k1KeyPair;
};

const getLinkedDataKeyPairsAtIndex = async (
  mnemonicContent: any,
  index: number
): Promise<any> => {
  const ed25519KeyPair = await getEd25519KeyPairFromMnemonicAtIndex(
    mnemonicContent,
    index
  );
  const secp256k1KeyPair = await getSecp256k1KeyPairFromMnemonicAtIndex(
    mnemonicContent,
    index
  );
  return [ed25519KeyPair, secp256k1KeyPair];
};

const toInitialState = async (secp256k1KeyPair: any) => {
  const updateAndRecoveryPublicKeyJwk = await secp256k1KeyPair.toJwk();

  const recovery_commitment = Multihash.canonicalizeThenHashThenEncode(
    updateAndRecoveryPublicKeyJwk
  );

  const delta_object = {
    update_commitment: recovery_commitment,
    patches: [
      {
        action: 'replace',
        document: {
          public_keys: [
            {
              id: updateAndRecoveryPublicKeyJwk.kid,
              type: 'JsonWebKey2020',
              jwk: updateAndRecoveryPublicKeyJwk,
              purpose: ['auth', 'general'],
            },
          ],
        },
      },
    ],
  };

  const delta_hash = Multihash.canonicalizeThenHashThenEncode(delta_object);

  const suffix_data_object = {
    delta_hash,
    recovery_commitment,
  };

  return (
    base64url.encode(JSON.stringify(suffix_data_object)) +
    '.' +
    base64url.encode(JSON.stringify(delta_object))
  );
};

const initialStateToShortFormDid = (initialState: string) => {
  const didMethodName = 'elem:ropsten';
  const parts = initialState.split('.');
  const didUniqueSuffix = Multihash.canonicalizeThenHashThenEncode(
    JSON.parse(base64url.decode(parts[0]))
  );
  const shortFormDid = `did:${didMethodName}:${didUniqueSuffix}`;
  return shortFormDid;
};

const getDerivedWalletContent = async (mnemonicContent: any, index: number) => {
  const [ed25519KeyPair, secp256k1KeyPair] = await getLinkedDataKeyPairsAtIndex(
    mnemonicContent,
    index
  );

  const ed25519WalletKeyPair = await toUniversalWalletDataModel(
    'KeyPair',
    ed25519KeyPair
  );
  ed25519WalletKeyPair.id = 'did:key:' + (await ed25519KeyPair.fingerprint());
  const secp256k1WalletKeyPair = await toUniversalWalletDataModel(
    'KeyPair',
    secp256k1KeyPair
  );
  secp256k1WalletKeyPair.id =
    'did:key:' + (await secp256k1KeyPair.fingerprint());

  const ed25519PublicKeyJwk = await ed25519KeyPair.toJwk();
  const secp256k1PublicKeyJwk = await secp256k1KeyPair.toJwk();

  const initialState = await toInitialState(secp256k1KeyPair);
  const shortFormDid = initialStateToShortFormDid(initialState);
  const longFormDid = shortFormDid + '?-elem-initial-state=' + initialState;

  ed25519KeyPair.controller = shortFormDid;
  ed25519KeyPair.id = '#' + ed25519PublicKeyJwk.kid;

  secp256k1KeyPair.controller = shortFormDid;
  secp256k1KeyPair.id = '#' + secp256k1PublicKeyJwk.kid;

  const [suffix_data, delta] = initialState.split('.');

  const createOperationRequest = {
    type: 'create',
    suffix_data,
    delta,
  };

  const walletContents = [ed25519WalletKeyPair, secp256k1WalletKeyPair].map(
    (content: any) => {
      return {
        ...content,
        // note the index that was used to generate this content
        correlation: [mnemonicContent.id + '#/index/' + index],
        // note the controller of this content
        controller: shortFormDid,
      };
    }
  );

  return {
    walletContents,
    longFormDid,
    createOperationRequest,
  };
};

export {
  generateMnemonic,
  toUniversalWalletDataModel,
  toInitialState,
  getLinkedDataKeyPairsAtIndex,
  getDerivedWalletContent,
};
